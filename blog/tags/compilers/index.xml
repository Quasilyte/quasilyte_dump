<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[compilers] on Iskander (Alex) Sharipov technical blog</title>
    <link>https://quasilyte.dev/blog/tags/compilers/</link>
    <description>Recent content in [compilers] on Iskander (Alex) Sharipov technical blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Mar 2020 17:08:04 +0000</lastBuildDate><atom:link href="https://quasilyte.dev/blog/tags/compilers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Let&#39;s Go write Pratt parsers!</title>
      <link>https://quasilyte.dev/blog/post/pratt-parsers-go/</link>
      <pubDate>Fri, 27 Mar 2020 17:08:04 +0000</pubDate>
      
      <guid>https://quasilyte.dev/blog/post/pratt-parsers-go/</guid>
      <description>Original (ru): https://habr.com/ru/post/494316/.
 Recursive descent parsing works well when you can continue parsing using the current context and a given token.
Some expressions make parsing harder: postfix, infix and other. They introduce a problem: you don&amp;rsquo;t know which kind of expression you&amp;rsquo;re processing until you&amp;rsquo;ve already parsed half of it. Most of the time you also care about operations precedence and their associativity, so the result AST has a proper shape.</description>
    </item>
    
    <item>
      <title>Go compiler: SSA optimization rules description language</title>
      <link>https://quasilyte.dev/blog/post/go_ssa_rules/</link>
      <pubDate>Sat, 30 Jun 2018 18:53:25 +0000</pubDate>
      
      <guid>https://quasilyte.dev/blog/post/go_ssa_rules/</guid>
      <description>Original (ru): https://habr.com/post/415771/.
 Go compiler uses its own Lisp-like domain-specific language (DSL) for Static Single Assignment (SSA) optimization rules description.
Lets dig into that language, its peculiarities and limitations. As an excercise, we&amp;rsquo;ll add a new optimization rule into Go compiler that would optimize expressions like a*b+c using new operations we&amp;rsquo;re going to implement along the way.
This is the first article in the series about Go compiler SSA backend, this is why I&amp;rsquo;ve included some fundamental and architectural info besides DSL overview.</description>
    </item>
    
    <item>
      <title>Writing Emacs Lisp compiler intrinsics</title>
      <link>https://quasilyte.dev/blog/post/writing-emacs-lisp-compiler-intrinsics/</link>
      <pubDate>Sat, 23 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.dev/blog/post/writing-emacs-lisp-compiler-intrinsics/</guid>
      <description>The problem Given a particular programming task in Emacs Lisp, you almost always should implement it with function. Sometimes, macro is a proper tool.
Even more rarely, cl-define-compiler-macro may be your choice.
All these methods are safe to use. They almost certanly will not break with newer Emacs versions.
One interesting task that can not be implemented efficiently with approaches that are outlined above is imperative return statement.
Emacs Lisp lacks this kind of flow control and this is a problem we are goind to attack today.</description>
    </item>
    
    <item>
      <title>RISC-V: custom instruction and its simulation</title>
      <link>https://quasilyte.dev/blog/post/riscv32-custom-instruction-and-its-simulation/</link>
      <pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://quasilyte.dev/blog/post/riscv32-custom-instruction-and-its-simulation/</guid>
      <description>Agenda This article shows how to add a new instruction to RISC-V and simulate it.
These topics are covered along the way:
 Whole GNU riscv toolchain installation; Implementation of a new instruction for spike RISC-V ISA simulator; Manual instruction encoding in C/C++; Custom instruction simulation (with visible output); [riscv32-]GCC plugin development;  You may find associated repository useful.
Many things can go wrong. Be prepared to fix upcoming issues by yourself.</description>
    </item>
    
  </channel>
</rss>
