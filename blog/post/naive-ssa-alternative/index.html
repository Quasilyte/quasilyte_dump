<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>A simpler scheme than SSA &middot; Iskander (Alex) Sharipov technical blog</title>
    <meta name="author" content="Iskander Sharipov">
    <meta name="description" content="Technical blog about systems programming and related topics">
    
    <meta name="generator" content="Hugo 0.91.0" />
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="google-site-verification" content="3arx-7OykUZQqhpkEeGzuoeRvjyl7Z13LgxXTtBB9vU" />

    <!-- RSS autodiscovery -->
    

    <link rel="shortcut icon" href="https://quasilyte.dev/blog/img/favicon.ico">
    <link rel="stylesheet" href="https://quasilyte.dev/blog/css/concatenated.css">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://quasilyte.dev/blog/css/screen.css">
    <link rel="stylesheet" href="https://quasilyte.dev/blog/hljs-themes/wombat.css">
    

    
        <link rel="shortcut icon" type="image/x-icon" href="https://quasilyte.dev/blog/favicon.ico">
        <link rel="icon" type="image/x-icon" href="https://quasilyte.dev/blog/favicon.ico">
    

    <!-- Stylesheet for theme color -->
    <style type="text/css">
    a, a:visited {color: #33cc99;}
    .pagination a {color: #33cc99;}
    .gist .gist-file .gist-meta a:visited {color: #33cc99 !important;}
    a:focus, a:hover {color: #178b6b;}
    h1.post-title a:focus, h1.post-title a:hover, h1.blog-title a:focus, h1.blog-title a:hover {color: #178b6b;}
    .older-posts:hover, .newer-posts:hover {color: #178b6b;}
</style>
</head>

<body class="home-template">
    <header id="site-head">
	
	<h1 class="blog-title"><a href="https://quasilyte.dev/blog/">quasilyte blog</a></h1>
	
	
	<h1 class="blog-subtitle">Technical blog about systems programming and related topics</h1>
	
</header>
    
<nav class="menu" role="nav">
    <ul>
        
        	<li class="nav nav-current"><a href="/blog/tags/">[Posts by tags]</a></li>
      	
        	<li class="nav nav-current"><a href="/blog/post/faq/#report-an-issue">[Report an issue]</a></li>
      	
        	<li class="nav nav-current"><a href="/blog/post/faq/#subscribe">[Subscribe]</a></li>
      	
    </ul>
</nav>

    
    <main class="content" role="main">
    
<article class="post">
    <header>
        <h1 class="post-title">A simpler scheme than SSA</h1>
        <div class="post-meta">
            <time datetime="26 March 2022">
                26 March 2022
            </time>
        </div>
    </header>

    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#ssa-complexities">SSA complexities</a></li><br>
    <li><a href="#unique-slots-form">Unique slots form</a></li><br>
    <li><a href="#marking-the-slots-as-unique">Marking the slots as unique</a></li><br>
    <li><a href="#when-exactly-to-insert-a-varkill">When exactly to insert a varkill</a></li><br>
  </ul>
</nav>
    
    <section class="post-content">
        <h2 id="ssa-complexities">SSA complexities</h2>
<p>Let&rsquo;s suppose that you&rsquo;re working on some small compiler-like project. At some point, you may start thinking about adding optimizations to the code generated by your compiler.</p>
<p>Then you realize that it&rsquo;s not enough to just have some IR that is suitable for modifications. It&rsquo;s important to apply only those optimizations that keep the code correct (or at least don&rsquo;t make it more broken than it was before). Hopefully, we&rsquo;re also making it faster or smaller along the way.</p>
<p>Most likely, you&rsquo;re better off choosing something like the SSA form. SSA form comes with a few complexities that you&rsquo;ll have to deal with:</p>
<ol>
<li>SSA introduces a lot of &ldquo;unique&rdquo; slots*. You need to perform good dead store optimizations and register allocation later on to keep the number of slots minimal</li>
<li>You either need to insert phi nodes or make basic blocks parametrized (so they get outer values as arguments)</li>
<li>SSA alone is not enough. You need some extra metadata, like the number of SSA value usages (most often you want to check whether <code>v.Uses == 1</code>)</li>
</ol>
<blockquote>
<p>(*) A slot is an abstract term for a place where we store some value. It could be someplace inside a stack, or a register, or a virtual register if we&rsquo;re talking about a VM with a potentially infinite amount of registers.</p>
</blockquote>
<p>Let&rsquo;s discuss the new issues one by one. We&rsquo;ll compare the state &ldquo;before&rdquo; and &ldquo;after&rdquo; the transition.</p>
<p>(1) It&rsquo;s quite easy to allocate a nearly minimal amount of slots linearly while compiling the code directly from AST to the target code. The potential waste can be near 20-30%, but it&rsquo;s good enough for a simple algorithm. Good registers allocation algorithms can&rsquo;t reach the perfect scenario either anyway.</p>
<p>(2) Phi nodes are OK since there is no way any SSA alternative can live without some kind of extra metadata encoded into the IR.</p>
<p>(3) Storing the usages counter per variable is OK too. Otherwise, it will be necessary to recompute this value multiple times, making some benefits of the SSA form go away.</p>
<p>In this article, I&rsquo;ll try to describe a simpler approach that:</p>
<ul>
<li>Keeps the allocated slots after the early compilation phase</li>
<li>Encodes both SSA unique value constraint with a single-use invariant (Uses=1)</li>
<li>This form is easy to build and maintain</li>
</ul>
<h2 id="unique-slots-form">Unique slots form</h2>
<p>We divide all slots into 2 categories:</p>
<ul>
<li>Normal slots</li>
<li>Unique slots</li>
</ul>
<p>Unique slots have these properties:</p>
<ul>
<li>They don&rsquo;t escape their basic block</li>
<li>They&rsquo;re only used once</li>
</ul>
<p>That being said, both unique and normal slots have assigned ID that tells which memory location they occupy. The same memory location can be unique in one part of the block and non-unique in another.</p>
<p>Our abstract slot can look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Slot</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">ID</span>     <span style="color:#66d9ef">int</span>  <span style="color:#75715e">// allocated by the compiler
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Unique</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// inferred by the optimizer
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Instructions operate on slots. Their arguments can have unique or non-unique slots:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Instruction</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Op</span>   <span style="color:#66d9ef">byte</span>
    <span style="color:#a6e22e">Args</span> []<span style="color:#a6e22e">Slot</span>
}
</code></pre></div><p>In the code below, <code>slot0</code> can be marked as unique:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#66d9ef">return</span> <span style="color:#ae81ff">130</span>

<span style="color:#75715e"># =&gt;</span>

load_int_const slot0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">130</span>
<span style="color:#66d9ef">return</span> slot0
</code></pre></div><p><code>slot0</code> is assigned exactly once, it&rsquo;s read only once as well. It doesn&rsquo;t leave its basic block too.</p>
<p>Here is an example of a block where we have a slot with the same ID marked as unique in several places:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">println(<span style="color:#ae81ff">130</span>)
println(<span style="color:#ae81ff">200</span>)

<span style="color:#75715e"># =&gt;</span>

load_int_const slot0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">130</span>
push_arg slot0
call println
load_int_const slot0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>
push_arg slot0
call println
</code></pre></div><p><code>slot0</code> is assigned twice, but both versions are unique: there is only one use after every assignment.</p>
<h2 id="marking-the-slots-as-unique">Marking the slots as unique</h2>
<p>In reality, we need some extra information to infer that some slot is unique. Namely, we need to know where its lifetime ends. This can be done with pseudo varkill instructions.</p>
<p>When the compiler allocates the slots for intermediate results, it knows when their lifetime ends. This lifetime tomb can end up in the same basic block or somewhere else.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">load_int_const slot0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">130</span>
push_arg slot0
call println
varkill slot0 <span style="color:#75715e"># &lt;- slot0 is free after this point</span>
load_int_const slot0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>
push_arg slot0
call println
varkill slot0 <span style="color:#75715e"># &lt;- slot0 is free after this point</span>
</code></pre></div><p>Now we can compute the unique slots with a linear algorithm, without any graph traversal:</p>
<ul>
<li>Go from the end of a basic block</li>
<li>Put all varkill IDs into a map</li>
<li>For every recorded ID, collect the number of reads</li>
<li>When reached recorded ID write, check the number of reads
<ul>
<li>If the number of reads is 0, this is a dead store</li>
<li>If the number of reads is 1, mark this slot and its usage as unique</li>
<li>Otherwise it&rsquo;s not a unique slot, remove ID from the map</li>
</ul>
</li>
<li>When removing a var or marking it unique, an associated varkill should be removed</li>
</ul>
<p>After the first round of optimizations, we need to re-compute the unique slots.</p>
<p>To avoid doing redundant re-calculations, we can skip blocks that don&rsquo;t have any varkills.</p>
<p>This means we need to store this number of varkills counter somewhere along the basic block. It&rsquo;s also possible to have a &ldquo;dirty&rdquo; flag inside a block that tells whether it may have changed after the last scanning.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Block</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Body</span>     []<span style="color:#a6e22e">Instruction</span>
    <span style="color:#a6e22e">Varkills</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">Dirty</span>    <span style="color:#66d9ef">bool</span>
}
</code></pre></div><p>Strictly speaking, explicit block objects are not required. All metadata can be stored separately, outside of the blocks. It is, however, more convenient to work with explicit block objects.</p>
<h2 id="when-exactly-to-insert-a-varkill">When exactly to insert a varkill</h2>
<p>For temporary values that are results of expression computation, it&rsquo;s simple. These are allocated along with the computations. The compiler knows then the expression boundary is over, so it can insert the tombstones right there.</p>
<p>For local variables, these life scopes can be computed using their lexical scoping.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// x slot is assigned when if statement &lt;init&gt; clause is being compiled
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(); <span style="color:#a6e22e">x</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
}
<span style="color:#75715e">// After the if statement is compiled, x variable is no longer alive,
</span><span style="color:#75715e">// a varkill for the allocated slot can be inserted.
</span><span style="color:#75715e"></span>
{
    <span style="color:#75715e">// This x variable is different from the previous one.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// In this case, the slot for x can be marked unique.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
    println(<span style="color:#a6e22e">x</span>)
    <span style="color:#75715e">// When this lexical block ends, x is no longer alive.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>For some simple cases, we can insert a varkill at the point of the variable reassignment. This is a more tricky case though: it&rsquo;s better to be conservative here and insert fewer markers than feeding the incorrect information to the optimizer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{
    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
    println(<span style="color:#a6e22e">x</span>)
    <span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">20</span> <span style="color:#75715e">// re-assigned: a suitable place for a varkill
</span><span style="color:#75715e"></span>    println(<span style="color:#a6e22e">x</span>)
}

<span style="color:#75715e">// =&gt;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// load_int_const slot0 = 10
</span><span style="color:#75715e">// push_arg slot0
</span><span style="color:#75715e">// call println
</span><span style="color:#75715e">// varkill slot0
</span><span style="color:#75715e">// load_int_const slot0 = 20
</span><span style="color:#75715e">// push_arg slot0
</span><span style="color:#75715e">// call println
</span></code></pre></div><p>We can&rsquo;t analyze all variables, but we can still get some benefits and perform safe optimizations without compromising the generated code correctness.</p>

    </section>

    
    <section class="post-tags" style="padding-bottom:60px;">
        <div class="post-meta tags">
            <i class="fa fa-fw fa-tag"></i>
            
                
                <a href="https://quasilyte.dev/blog/tags/go">[go] </a>
            
                
                <a href="https://quasilyte.dev/blog/tags/compilers">[compilers] </a>
            
                
                <a href="https://quasilyte.dev/blog/tags/shortread">[shortread] </a>
            
                
                <a href="https://quasilyte.dev/blog/tags/ssa">[ssa] </a>
            
        </div>
    </section>
    
    
    <section class="share">
    <p class="backtotop"><a data-scroll href="#site-head"><i class="fa fa-lg fa-fw fa-angle-double-up"></i></a><a data-scroll class="backtotoptext" href="#site-head"> Back to top</a></p>
    <p class="info prompt">Share</p>
    <a href="http://twitter.com/share?text=A%20simpler%20scheme%20than%20SSA&url=https%3a%2f%2fquasilyte.dev%2fblog%2fpost%2fnaive-ssa-alternative%2f" title="Share on Twitter"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-2x fa-fw fa-twitter-square"></i> <span class="hidden">Twitter</span>
    </a>
    <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fquasilyte.dev%2fblog%2fpost%2fnaive-ssa-alternative%2f" title="Share on Facebook"
        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="fa fa-2x fa-fw fa-facebook-square" style="margin-left: -8px"></i> <span class="hidden">Facebook</span>
    </a>
    <a href="https://plus.google.com/share?url=https%3a%2f%2fquasilyte.dev%2fblog%2fpost%2fnaive-ssa-alternative%2f" title="Share on Google+"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <i class="fa fa-2x fa-fw fa-google-plus-square" style="margin-left: -8px"></i> <span class="hidden">Google+</span>
    </a>
</section>

    <footer class="post-footer">
        <section class="author">
    <div class="authorimage" style="background: url(https://quasilyte.dev/blog/img/avatar.jpg)"></div>
    <h4>Iskander Sharipov</h4>
    <p class="bio">Lisper that got lost in a gophers land</p>
    <p class="meta">
      
    </p>
</section>
    </footer>
    
</article>

    </main>

    <footer class="site-footer">
	<div class="inner">
		<section class="footer-social">
      
      <a href="//twitter.com/quasilyte" target="_blank" title="Twitter"><i class="fa fa-2x fa-fw fa-twitter"></i> <span class="hidden">Twitter</span></a>&nbsp;
      
      
      <a href="//www.linkedin.com/in/quasilyte" target="_blank" title="linkedIn"><i class="fa fa-2x fa-fw fa-linkedin"></i> <span class="hidden">LinkedIn</span></a>&nbsp;
      
      
      
      
      
      <a href="//github.com/quasilyte" target="_blank" title="GitHub"><i class="fa fa-2x fa-fw fa-github"></i> <span class="hidden">GitHub</span></a>&nbsp;
      
      
      
      
  </section>

		<section class="copyright">&copy; 2022 <a href="https://quasilyte.dev/blog/">Iskander Sharipov</a>. Released under the MIT license.</section>
	</div>
</footer>

    <script src="https://quasilyte.dev/blog/jquery.min.js"></script>
<script src="https://quasilyte.dev/blog/js/index.js"></script>
<script src="https://quasilyte.dev/blog/js/smooth-scroll.min.js"></script>
<script src="https://quasilyte.dev/blog/highlight.pack.js"></script>


<script>
    smoothScroll.init({
        speed: 800,
        easing: 'easeInOutCubic',
        updateURL: false,
        offset: 125,
    });
</script>
<script>hljs.initHighlightingOnLoad();</script>


</body>
</html>